shadow$provide.module$node_modules$$mui$material$node$TextareaAutosize$TextareaAutosize = function(global, require, module, exports) {
  "use client";
  global = require("module$node_modules$$babel$runtime$helpers$interopRequireDefault").default;
  module = require("module$node_modules$$babel$runtime$helpers$interopRequireWildcard").default;
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.default = void 0;
  var React = module(require("module$node_modules$react$index"));
  global = global(require("module$node_modules$prop_types$index"));
  var _utils = require("module$node_modules$$mui$utils$index"), _jsxRuntime = require("module$node_modules$react$jsx_runtime"), JSCompiler_object_inline_shadow_123 = {visibility:"hidden", position:"absolute", overflow:"hidden", height:0, top:0, left:0, transform:"translateZ(0)"};
  require = React.forwardRef(function(props, forwardedRef) {
    const {onChange, maxRows, minRows = 1, style, value, ...other} = props, {current:isControlled} = React.useRef(null != value), inputRef = React.useRef(null);
    forwardedRef = (0,_utils.unstable_useForkRef)(forwardedRef, inputRef);
    const heightRef = React.useRef(null), shadowRef = React.useRef(null), calculateTextareaStyles = React.useCallback(() => {
      var input = inputRef.current, computedStyle = (0,_utils.unstable_ownerWindow)(input).getComputedStyle(input);
      if ("0px" === computedStyle.width) {
        return {outerHeightStyle:0, overflowing:!1};
      }
      var inputShallow = shadowRef.current;
      inputShallow.style.width = computedStyle.width;
      inputShallow.value = input.value || props.placeholder || "x";
      "\n" === inputShallow.value.slice(-1) && (inputShallow.value += " ");
      input = computedStyle.boxSizing;
      const padding = (parseInt(computedStyle.paddingBottom, 10) || 0) + (parseInt(computedStyle.paddingTop, 10) || 0);
      computedStyle = (parseInt(computedStyle.borderBottomWidth, 10) || 0) + (parseInt(computedStyle.borderTopWidth, 10) || 0);
      const innerHeight = inputShallow.scrollHeight;
      inputShallow.value = "x";
      inputShallow = inputShallow.scrollHeight;
      let outerHeight = innerHeight;
      minRows && (outerHeight = Math.max(Number(minRows) * inputShallow, outerHeight));
      maxRows && (outerHeight = Math.min(Number(maxRows) * inputShallow, outerHeight));
      outerHeight = Math.max(outerHeight, inputShallow);
      return {outerHeightStyle:outerHeight + ("border-box" === input ? padding + computedStyle : 0), overflowing:1 >= Math.abs(outerHeight - innerHeight)};
    }, [maxRows, minRows, props.placeholder]), syncHeight = React.useCallback(() => {
      const textareaStyles = calculateTextareaStyles();
      if (void 0 !== textareaStyles && null !== textareaStyles && 0 !== Object.keys(textareaStyles).length && (0 !== textareaStyles.outerHeightStyle || textareaStyles.overflowing)) {
        var outerHeightStyle = textareaStyles.outerHeightStyle, input = inputRef.current;
        heightRef.current !== outerHeightStyle && (heightRef.current = outerHeightStyle, input.style.height = `${outerHeightStyle}px`);
        input.style.overflow = textareaStyles.overflowing ? "hidden" : "";
      }
    }, [calculateTextareaStyles]);
    (0,_utils.unstable_useEnhancedEffect)(() => {
      const handleResize = () => {
        syncHeight();
      }, debounceHandleResize = (0,_utils.unstable_debounce)(handleResize), input = inputRef.current, containerWindow = (0,_utils.unstable_ownerWindow)(input);
      containerWindow.addEventListener("resize", debounceHandleResize);
      let resizeObserver;
      "undefined" !== typeof ResizeObserver && (resizeObserver = new ResizeObserver(handleResize), resizeObserver.observe(input));
      return () => {
        debounceHandleResize.clear();
        cancelAnimationFrame(void 0);
        containerWindow.removeEventListener("resize", debounceHandleResize);
        resizeObserver && resizeObserver.disconnect();
      };
    }, [calculateTextareaStyles, syncHeight]);
    (0,_utils.unstable_useEnhancedEffect)(() => {
      syncHeight();
    });
    return (0,_jsxRuntime.jsxs)(React.Fragment, {children:[(0,_jsxRuntime.jsx)("textarea", {value, onChange:event => {
      isControlled || syncHeight();
      onChange && onChange(event);
    }, ref:forwardedRef, rows:minRows, style, ...other}), (0,_jsxRuntime.jsx)("textarea", {"aria-hidden":!0, className:props.className, readOnly:!0, ref:shadowRef, tabIndex:-1, style:{...JSCompiler_object_inline_shadow_123, ...style, paddingTop:0, paddingBottom:0}})]});
  });
  require.propTypes = {className:global.default.string, maxRows:global.default.oneOfType([global.default.number, global.default.string]), minRows:global.default.oneOfType([global.default.number, global.default.string]), onChange:global.default.func, placeholder:global.default.string, style:global.default.object, value:global.default.oneOfType([global.default.arrayOf(global.default.string), global.default.number, global.default.string])};
  exports.default = require;
};

//# sourceMappingURL=module$node_modules$$mui$material$node$TextareaAutosize$TextareaAutosize.js.map
