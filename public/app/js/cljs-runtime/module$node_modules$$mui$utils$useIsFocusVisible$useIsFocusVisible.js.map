{
"version":3,
"file":"module$node_modules$$mui$utils$useIsFocusVisible$useIsFocusVisible.js",
"lineCount":49,
"mappings":"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",
"sources":["node_modules/@mui/utils/useIsFocusVisible/useIsFocusVisible.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$mui$utils$useIsFocusVisible$useIsFocusVisible\"] = function(global,require,module,exports) {\n\"use strict\";\n'use client';\n\n// based on https://github.com/WICG/focus-visible/blob/v4.1.5/src/focus-visible.js\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = useIsFocusVisible;\nexports.teardown = teardown;\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _useTimeout = require(\"../useTimeout/useTimeout\");\nlet hadKeyboardEvent = true;\nlet hadFocusVisibleRecently = false;\nconst hadFocusVisibleRecentlyTimeout = new _useTimeout.Timeout();\nconst inputTypesWhitelist = {\n  text: true,\n  search: true,\n  url: true,\n  tel: true,\n  email: true,\n  password: true,\n  number: true,\n  date: true,\n  month: true,\n  week: true,\n  time: true,\n  datetime: true,\n  'datetime-local': true\n};\n\n/**\n * Computes whether the given element should automatically trigger the\n * `focus-visible` class being added, i.e. whether it should always match\n * `:focus-visible` when focused.\n * @param {Element} node\n * @returns {boolean}\n */\nfunction focusTriggersKeyboardModality(node) {\n  const {\n    type,\n    tagName\n  } = node;\n  if (tagName === 'INPUT' && inputTypesWhitelist[type] && !node.readOnly) {\n    return true;\n  }\n  if (tagName === 'TEXTAREA' && !node.readOnly) {\n    return true;\n  }\n  if (node.isContentEditable) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Keep track of our keyboard modality state with `hadKeyboardEvent`.\n * If the most recent user interaction was via the keyboard;\n * and the key press did not include a meta, alt/option, or control key;\n * then the modality is keyboard. Otherwise, the modality is not keyboard.\n * @param {KeyboardEvent} event\n */\nfunction handleKeyDown(event) {\n  if (event.metaKey || event.altKey || event.ctrlKey) {\n    return;\n  }\n  hadKeyboardEvent = true;\n}\n\n/**\n * If at any point a user clicks with a pointing device, ensure that we change\n * the modality away from keyboard.\n * This avoids the situation where a user presses a key on an already focused\n * element, and then clicks on a different element, focusing it with a\n * pointing device, while we still think we're in keyboard modality.\n */\nfunction handlePointerDown() {\n  hadKeyboardEvent = false;\n}\nfunction handleVisibilityChange() {\n  if (this.visibilityState === 'hidden') {\n    // If the tab becomes active again, the browser will handle calling focus\n    // on the element (Safari actually calls it twice).\n    // If this tab change caused a blur on an element with focus-visible,\n    // re-apply the class when the user switches back to the tab.\n    if (hadFocusVisibleRecently) {\n      hadKeyboardEvent = true;\n    }\n  }\n}\nfunction prepare(doc) {\n  doc.addEventListener('keydown', handleKeyDown, true);\n  doc.addEventListener('mousedown', handlePointerDown, true);\n  doc.addEventListener('pointerdown', handlePointerDown, true);\n  doc.addEventListener('touchstart', handlePointerDown, true);\n  doc.addEventListener('visibilitychange', handleVisibilityChange, true);\n}\nfunction teardown(doc) {\n  doc.removeEventListener('keydown', handleKeyDown, true);\n  doc.removeEventListener('mousedown', handlePointerDown, true);\n  doc.removeEventListener('pointerdown', handlePointerDown, true);\n  doc.removeEventListener('touchstart', handlePointerDown, true);\n  doc.removeEventListener('visibilitychange', handleVisibilityChange, true);\n}\nfunction isFocusVisible(event) {\n  const {\n    target\n  } = event;\n  try {\n    return target.matches(':focus-visible');\n  } catch (error) {\n    // Browsers not implementing :focus-visible will throw a SyntaxError.\n    // We use our own heuristic for those browsers.\n    // Rethrow might be better if it's not the expected error but do we really\n    // want to crash if focus-visible malfunctioned?\n  }\n\n  // No need for validFocusTarget check. The user does that by attaching it to\n  // focusable events only.\n  return hadKeyboardEvent || focusTriggersKeyboardModality(target);\n}\nfunction useIsFocusVisible() {\n  const ref = React.useCallback(node => {\n    if (node != null) {\n      prepare(node.ownerDocument);\n    }\n  }, []);\n  const isFocusVisibleRef = React.useRef(false);\n\n  /**\n   * Should be called if a blur event is fired\n   */\n  function handleBlurVisible() {\n    // checking against potential state variable does not suffice if we focus and blur synchronously.\n    // React wouldn't have time to trigger a re-render so `focusVisible` would be stale.\n    // Ideally we would adjust `isFocusVisible(event)` to look at `relatedTarget` for blur events.\n    // This doesn't work in IE11 due to https://github.com/facebook/react/issues/3751\n    // TODO: check again if React releases their internal changes to focus event handling (https://github.com/facebook/react/pull/19186).\n    if (isFocusVisibleRef.current) {\n      // To detect a tab/window switch, we look for a blur event followed\n      // rapidly by a visibility change.\n      // If we don't see a visibility change within 100ms, it's probably a\n      // regular focus change.\n      hadFocusVisibleRecently = true;\n      hadFocusVisibleRecentlyTimeout.start(100, () => {\n        hadFocusVisibleRecently = false;\n      });\n      isFocusVisibleRef.current = false;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Should be called if a blur event is fired\n   */\n  function handleFocusVisible(event) {\n    if (isFocusVisible(event)) {\n      isFocusVisibleRef.current = true;\n      return true;\n    }\n    return false;\n  }\n  return {\n    isFocusVisibleRef,\n    onFocus: handleFocusVisible,\n    onBlur: handleBlurVisible,\n    ref\n  };\n}\n};"],
"names":["shadow$provide","global","require","module","exports","handleKeyDown","event","metaKey","altKey","ctrlKey","hadKeyboardEvent","handlePointerDown","handleVisibilityChange","visibilityState","hadFocusVisibleRecently","_interopRequireWildcard","default","Object","defineProperty","value","useIsFocusVisible","ref","React","useCallback","node","ownerDocument","doc","addEventListener","isFocusVisibleRef","useRef","onFocus","handleFocusVisible","target","matches","error","type","tagName","inputTypesWhitelist","readOnly","isContentEditable","current","onBlur","handleBlurVisible","hadFocusVisibleRecentlyTimeout","start","teardown","removeEventListener","_useTimeout","Timeout","text","search","url","tel","email","password","number","date","month","week","time","datetime"]
}
