{
"version":3,
"file":"module$node_modules$$mui$utils$useForkRef$useForkRef.js",
"lineCount":15,
"mappings":"AAAAA,cAAA,CAAA,oDAAA,GAAyE,QAAQ,CAACC,MAAD,EAAQC,OAAR,EAAgBC,MAAhB,EAAuBC,OAAvB,CAAgC;AAEjH,cAAA;AAEIC,QAAAA,GAAyBH,OAAA,CAAQ,kEAAR,CAAwDI,CAAAA,OAAjFD;AACAE,QAAAA,GAA0BL,OAAA,CAAQ,mEAAR,CAAyDI,CAAAA,OAAnFC;AACJC,QAAOC,CAAAA,cAAP,CAAsBL,OAAtB,EAA+B,YAA/B,EAA6C,CAC3CM,MAAO,CAAA,CADoC,CAA7C,CAAA;AAGAN,SAAQE,CAAAA,OAAR,GAGAK,QAAmB,CAAC,GAAGC,IAAJ,CAAU;AAM3B,WAAOC,KAAMC,CAAAA,OAAN,CAAc,EAAA,IACfF,IAAKG,CAAAA,KAAL,CAAWC,GAAA,IAAc,IAAd,IAAOA,GAAlB,CAAJ,GACS,IADT,GAGOC,QAAA,IAAY;AACjBL,UAAKM,CAAAA,OAAL,CAAaF,GAAA,IAAO;AAClB,WAAIG,OAAQb,CAAAA,OAAZ,EAAqBU,GAArB,EAA0BC,QAA1B,CAAA;AADkB,OAApB,CAAA;AADiB,KAJd,EAWJL,IAXI,CAAP;AAN2B,GAH7B;AACA,MAAIC,QAAQN,MAAA,CAAwBL,OAAA,CAAQ,iCAAR,CAAxB,CAAZ,EACIiB,UAAUd,MAAA,CAAuBH,OAAA,CAAQ,6CAAR,CAAvB,CADd;AAViH,CAAjH;;",
"sources":["node_modules/@mui/utils/useForkRef/useForkRef.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$mui$utils$useForkRef$useForkRef\"] = function(global,require,module,exports) {\n\"use strict\";\n'use client';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = useForkRef;\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _setRef = _interopRequireDefault(require(\"../setRef\"));\nfunction useForkRef(...refs) {\n  /**\n   * This will create a new function if the refs passed to this hook change and are all defined.\n   * This means react will call the old forkRef with `null` and the new forkRef\n   * with the ref. Cleanup naturally emerges from this behavior.\n   */\n  return React.useMemo(() => {\n    if (refs.every(ref => ref == null)) {\n      return null;\n    }\n    return instance => {\n      refs.forEach(ref => {\n        (0, _setRef.default)(ref, instance);\n      });\n    };\n    // TODO: uncomment once we enable eslint-plugin-react-compiler // eslint-disable-next-line react-compiler/react-compiler -- intentionally ignoring that the dependency array must be an array literal\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, refs);\n}\n};"],
"names":["shadow$provide","global","require","module","exports","_interopRequireDefault","default","_interopRequireWildcard","Object","defineProperty","value","useForkRef","refs","React","useMemo","every","ref","instance","forEach","_setRef"]
}
