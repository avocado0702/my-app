shadow$provide.module$node_modules$$mui$system$breakpoints$breakpoints = function(global, require, module, exports) {
  function createEmptyBreakpointObject(breakpointsInput = {}) {
    return breakpointsInput.keys?.reduce((acc, key) => {
      key = breakpointsInput.up(key);
      acc[key] = {};
      return acc;
    }, {}) || {};
  }
  function removeUnusedBreakpoints(breakpointKeys, style) {
    return breakpointKeys.reduce((acc, key) => {
      const breakpointOutput = acc[key];
      breakpointOutput && 0 !== Object.keys(breakpointOutput).length || delete acc[key];
      return acc;
    }, style);
  }
  function computeBreakpointsBase(breakpointValues, themeBreakpoints) {
    if ("object" !== typeof breakpointValues) {
      return {};
    }
    const base = {};
    themeBreakpoints = Object.keys(themeBreakpoints);
    Array.isArray(breakpointValues) ? themeBreakpoints.forEach((breakpoint, i) => {
      i < breakpointValues.length && (base[breakpoint] = !0);
    }) : themeBreakpoints.forEach(breakpoint => {
      null != breakpointValues[breakpoint] && (base[breakpoint] = !0);
    });
    return base;
  }
  global = require("module$node_modules$$babel$runtime$helpers$interopRequireDefault").default;
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.computeBreakpointsBase = computeBreakpointsBase;
  exports.createEmptyBreakpointObject = createEmptyBreakpointObject;
  exports.default = void 0;
  exports.handleBreakpoints = function(props, propValue, styleFromPropValue) {
    const theme = props.theme || {};
    if (Array.isArray(propValue)) {
      const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
      return propValue.reduce((acc, item, index) => {
        acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
        return acc;
      }, {});
    }
    if ("object" === typeof propValue) {
      const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
      return Object.keys(propValue).reduce((acc, breakpoint) => {
        if ((0,_cssContainerQueries.isCqShorthand)(themeBreakpoints.keys, breakpoint)) {
          var containerKey = (0,_cssContainerQueries.getContainerQuery)(theme.containerQueries ? theme : defaultContainerQueries, breakpoint);
          containerKey && (acc[containerKey] = styleFromPropValue(propValue[breakpoint], breakpoint));
        } else {
          Object.keys(themeBreakpoints.values || values).includes(breakpoint) ? (containerKey = themeBreakpoints.up(breakpoint), acc[containerKey] = styleFromPropValue(propValue[breakpoint], breakpoint)) : acc[breakpoint] = propValue[breakpoint];
        }
        return acc;
      }, {});
    }
    return styleFromPropValue(propValue);
  };
  exports.mergeBreakpointsInOrder = function(breakpointsInput, ...styles) {
    breakpointsInput = createEmptyBreakpointObject(breakpointsInput);
    styles = [breakpointsInput, ...styles].reduce((prev, next) => (0,_deepmerge.default)(prev, next), {});
    return removeUnusedBreakpoints(Object.keys(breakpointsInput), styles);
  };
  exports.removeUnusedBreakpoints = removeUnusedBreakpoints;
  exports.resolveBreakpointValues = function({values:breakpointValues, breakpoints:themeBreakpoints, base:customBase}) {
    themeBreakpoints = customBase || computeBreakpointsBase(breakpointValues, themeBreakpoints);
    themeBreakpoints = Object.keys(themeBreakpoints);
    if (0 === themeBreakpoints.length) {
      return breakpointValues;
    }
    let previous;
    return themeBreakpoints.reduce((acc, breakpoint, i) => {
      Array.isArray(breakpointValues) ? (acc[breakpoint] = null != breakpointValues[i] ? breakpointValues[i] : breakpointValues[previous], previous = i) : "object" === typeof breakpointValues ? (acc[breakpoint] = null != breakpointValues[breakpoint] ? breakpointValues[breakpoint] : breakpointValues[previous], previous = breakpoint) : acc[breakpoint] = breakpointValues;
      return acc;
    }, {});
  };
  exports.values = void 0;
  var _propTypes = global(require("module$node_modules$prop_types$index")), _deepmerge = global(require("module$node_modules$$mui$utils$deepmerge$index")), _merge = global(require("module$node_modules$$mui$system$merge$index")), _cssContainerQueries = require("module$node_modules$$mui$system$cssContainerQueries$index");
  const values = exports.values = {xs:0, sm:600, md:900, lg:1200, xl:1536}, defaultBreakpoints = {keys:["xs", "sm", "md", "lg", "xl"], up:key => `@media (min-width:${values[key]}px)`}, defaultContainerQueries = {containerQueries:containerName => ({up:key => {
    key = "number" === typeof key ? key : values[key] || key;
    "number" === typeof key && (key = `${key}px`);
    return containerName ? `@container ${containerName} (min-width:${key})` : `@container (min-width:${key})`;
  }})};
  exports.default = function(styleFunction) {
    const newStyleFunction = props => {
      const theme = props.theme || {}, base = styleFunction(props), themeBreakpoints = theme.breakpoints || defaultBreakpoints, extended = themeBreakpoints.keys.reduce((acc, key) => {
        props[key] && (acc = acc || {}, acc[themeBreakpoints.up(key)] = styleFunction({theme, ...props[key]}));
        return acc;
      }, null);
      return (0,_merge.default)(base, extended);
    };
    newStyleFunction.propTypes = {...styleFunction.propTypes, xs:_propTypes.default.object, sm:_propTypes.default.object, md:_propTypes.default.object, lg:_propTypes.default.object, xl:_propTypes.default.object};
    newStyleFunction.filterProps = ["xs", "sm", "md", "lg", "xl", ...styleFunction.filterProps];
    return newStyleFunction;
  };
};

//# sourceMappingURL=module$node_modules$$mui$system$breakpoints$breakpoints.js.map
