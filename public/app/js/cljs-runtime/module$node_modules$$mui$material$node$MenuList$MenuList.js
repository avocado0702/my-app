shadow$provide.module$node_modules$$mui$material$node$MenuList$MenuList = function(global, require, module, exports) {
  function nextItem(list, item, disableListWrap) {
    return list === item ? list.firstChild : item && item.nextElementSibling ? item.nextElementSibling : disableListWrap ? null : list.firstChild;
  }
  function previousItem(list, item, disableListWrap) {
    return list === item ? disableListWrap ? list.firstChild : list.lastChild : item && item.previousElementSibling ? item.previousElementSibling : disableListWrap ? null : list.lastChild;
  }
  function textCriteriaMatches(nextFocus, textCriteria) {
    if (void 0 === textCriteria) {
      return !0;
    }
    let text = nextFocus.innerText;
    void 0 === text && (text = nextFocus.textContent);
    text = text.trim().toLowerCase();
    return 0 === text.length ? !1 : textCriteria.repeating ? text[0] === textCriteria.keys[0] : text.startsWith(textCriteria.keys.join(""));
  }
  function moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {
    let wrappedOnce = !1;
    for (currentFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : !1); currentFocus;) {
      if (currentFocus === list.firstChild) {
        if (wrappedOnce) {
          break;
        }
        wrappedOnce = !0;
      }
      const nextFocusDisabled = disabledItemsFocusable ? !1 : currentFocus.disabled || "true" === currentFocus.getAttribute("aria-disabled");
      if (currentFocus.hasAttribute("tabindex") && textCriteriaMatches(currentFocus, textCriteria) && !nextFocusDisabled) {
        return currentFocus.focus(), !0;
      }
      currentFocus = traversalFunction(list, currentFocus, disableListWrap);
    }
    return !1;
  }
  "use client";
  global = require("module$node_modules$$babel$runtime$helpers$interopRequireDefault").default;
  module = require("module$node_modules$$babel$runtime$helpers$interopRequireWildcard").default;
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.default = void 0;
  var React = module(require("module$node_modules$react$index")), _reactIs = require("module$node_modules$react_is$index");
  module = global(require("module$node_modules$prop_types$index"));
  var _ownerDocument = global(require("module$node_modules$$mui$material$node$utils$ownerDocument")), _List = global(require("module$node_modules$$mui$material$node$List$index")), _getScrollbarSize = global(require("module$node_modules$$mui$material$node$utils$getScrollbarSize")), _useForkRef = global(require("module$node_modules$$mui$material$node$utils$useForkRef")), _useEnhancedEffect = global(require("module$node_modules$$mui$material$node$utils$useEnhancedEffect")), _utils = require("module$node_modules$$mui$material$node$utils$index"), 
  _jsxRuntime = require("module$node_modules$react$jsx_runtime");
  require = React.forwardRef(function(props, ref) {
    const {actions, autoFocus = !1, autoFocusItem = !1, children, className, disabledItemsFocusable = !1, disableListWrap = !1, onKeyDown, variant = "selectedMenu", ...other} = props, listRef = React.useRef(null), textCriteriaRef = React.useRef({keys:[], repeating:!0, previousKeyMatched:!0, lastTime:null});
    (0,_useEnhancedEffect.default)(() => {
      autoFocus && listRef.current.focus();
    }, [autoFocus]);
    React.useImperativeHandle(actions, () => ({adjustStyleForScrollbar:(containerElement, {direction}) => {
      const noExplicitWidth = !listRef.current.style.width;
      containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth && (containerElement = `${(0,_getScrollbarSize.default)((0,_utils.ownerWindow)(containerElement))}px`, listRef.current.style["rtl" === direction ? "paddingLeft" : "paddingRight"] = containerElement, listRef.current.style.width = `calc(100% + ${containerElement})`);
      return listRef.current;
    }}), []);
    props = (0,_useForkRef.default)(listRef, ref);
    let activeItemIndex = -1;
    React.Children.forEach(children, (child, index) => {
      React.isValidElement(child) ? ((0,_reactIs.isFragment)(child) && console.error("MUI: The Menu component doesn't accept a Fragment as a child.\nConsider providing an array instead."), child.props.disabled || ("selectedMenu" === variant && child.props.selected ? activeItemIndex = index : -1 === activeItemIndex && (activeItemIndex = index)), activeItemIndex === index && (child.props.disabled || child.props.muiSkipListHighlight || child.type.muiSkipListHighlight) && (activeItemIndex += 1, activeItemIndex >= 
      children.length && (activeItemIndex = -1))) : activeItemIndex === index && (activeItemIndex += 1, activeItemIndex >= children.length && (activeItemIndex = -1));
    });
    ref = React.Children.map(children, (child, index) => index === activeItemIndex ? (index = {}, autoFocusItem && (index.autoFocus = !0), void 0 === child.props.tabIndex && "selectedMenu" === variant && (index.tabIndex = 0), React.cloneElement(child, index)) : child);
    return (0,_jsxRuntime.jsx)(_List.default, {role:"menu", ref:props, className, onKeyDown:event => {
      const list = listRef.current;
      var key = event.key;
      if (!(event.ctrlKey || event.metaKey || event.altKey)) {
        var currentFocus = (0,_ownerDocument.default)(list).activeElement;
        if ("ArrowDown" === key) {
          event.preventDefault(), moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem);
        } else if ("ArrowUp" === key) {
          event.preventDefault(), moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem);
        } else if ("Home" === key) {
          event.preventDefault(), moveFocus(list, null, disableListWrap, disabledItemsFocusable, nextItem);
        } else if ("End" === key) {
          event.preventDefault(), moveFocus(list, null, disableListWrap, disabledItemsFocusable, previousItem);
        } else if (1 === key.length) {
          const criteria = textCriteriaRef.current;
          key = key.toLowerCase();
          const currTime = performance.now();
          0 < criteria.keys.length && (500 < currTime - criteria.lastTime ? (criteria.keys = [], criteria.repeating = !0, criteria.previousKeyMatched = !0) : criteria.repeating && key !== criteria.keys[0] && (criteria.repeating = !1));
          criteria.lastTime = currTime;
          criteria.keys.push(key);
          key = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);
          criteria.previousKeyMatched && (key || moveFocus(list, currentFocus, !1, disabledItemsFocusable, nextItem, criteria)) ? event.preventDefault() : criteria.previousKeyMatched = !1;
        }
      }
      onKeyDown && onKeyDown(event);
    }, tabIndex:autoFocus ? 0 : -1, ...other, children:ref});
  });
  require.propTypes = {autoFocus:module.default.bool, autoFocusItem:module.default.bool, children:module.default.node, className:module.default.string, disabledItemsFocusable:module.default.bool, disableListWrap:module.default.bool, onKeyDown:module.default.func, variant:module.default.oneOf(["menu", "selectedMenu"])};
  exports.default = require;
};

//# sourceMappingURL=module$node_modules$$mui$material$node$MenuList$MenuList.js.map
