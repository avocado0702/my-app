shadow$provide.module$node_modules$$mui$material$node$ButtonBase$TouchRipple = function(global, require, module, exports) {
  "use client";
  var _interopRequireDefault = require("module$node_modules$$babel$runtime$helpers$interopRequireDefault").default;
  global = require("module$node_modules$$babel$runtime$helpers$interopRequireWildcard").default;
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.default = exports.TouchRippleRoot = exports.TouchRippleRipple = exports.DELAY_RIPPLE = void 0;
  var React = global(require("module$node_modules$react$index"));
  global = _interopRequireDefault(require("module$node_modules$prop_types$index"));
  var _reactTransitionGroup = require("module$node_modules$react_transition_group$cjs$index"), _clsx = _interopRequireDefault(require("module$node_modules$clsx$dist$clsx")), _useTimeout = _interopRequireDefault(require("module$node_modules$$mui$utils$useTimeout$index"));
  module = require("module$node_modules$$mui$material$node$zero_styled$index");
  var _DefaultPropsProvider = require("module$node_modules$$mui$material$node$DefaultPropsProvider$index"), _Ripple = _interopRequireDefault(require("module$node_modules$$mui$material$node$ButtonBase$Ripple")), _touchRippleClasses = _interopRequireDefault(require("module$node_modules$$mui$material$node$ButtonBase$touchRippleClasses")), _jsxRuntime = require("module$node_modules$react$jsx_runtime");
  const DELAY_RIPPLE = exports.DELAY_RIPPLE = 80;
  require = (0,module.keyframes)`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`;
  _interopRequireDefault = (0,module.keyframes)`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`;
  const pulsateKeyframe = (0,module.keyframes)`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`, TouchRippleRoot = exports.TouchRippleRoot = (0,module.styled)("span", {name:"MuiTouchRipple", slot:"Root"})({overflow:"hidden", pointerEvents:"none", position:"absolute", zIndex:0, top:0, right:0, bottom:0, left:0, borderRadius:"inherit"}), TouchRippleRipple = exports.TouchRippleRipple = (0,module.styled)(_Ripple.default, {name:"MuiTouchRipple", slot:"Ripple"})`
  opacity: 0;
  position: absolute;

  &.${_touchRippleClasses.default.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${require};
    animation-duration: ${550}ms;
    animation-timing-function: ${({theme}) => theme.transitions.easing.easeInOut};
  }

  &.${_touchRippleClasses.default.ripplePulsate} {
    animation-duration: ${({theme}) => theme.transitions.duration.shorter}ms;
  }

  & .${_touchRippleClasses.default.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${_touchRippleClasses.default.childLeaving} {
    opacity: 0;
    animation-name: ${_interopRequireDefault};
    animation-duration: ${550}ms;
    animation-timing-function: ${({theme}) => theme.transitions.easing.easeInOut};
  }

  & .${_touchRippleClasses.default.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${pulsateKeyframe};
    animation-duration: 2500ms;
    animation-timing-function: ${({theme}) => theme.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`;
  require = React.forwardRef(function(inProps, ref) {
    inProps = (0,_DefaultPropsProvider.useDefaultProps)({props:inProps, name:"MuiTouchRipple"});
    const {center:centerProp = !1, classes = {}, className, ...other} = inProps, [ripples, setRipples] = React.useState([]), nextKey = React.useRef(0), rippleCallback = React.useRef(null);
    React.useEffect(() => {
      rippleCallback.current && (rippleCallback.current(), rippleCallback.current = null);
    }, [ripples]);
    const ignoringMouseDown = React.useRef(!1), startTimer = (0,_useTimeout.default)(), startTimerCommit = React.useRef(null), container = React.useRef(null), startCommit = React.useCallback(params => {
      const {pulsate, rippleX, rippleY, rippleSize, cb} = params;
      setRipples(oldRipples => [...oldRipples, (0,_jsxRuntime.jsx)(TouchRippleRipple, {classes:{ripple:(0,_clsx.default)(classes.ripple, _touchRippleClasses.default.ripple), rippleVisible:(0,_clsx.default)(classes.rippleVisible, _touchRippleClasses.default.rippleVisible), ripplePulsate:(0,_clsx.default)(classes.ripplePulsate, _touchRippleClasses.default.ripplePulsate), child:(0,_clsx.default)(classes.child, _touchRippleClasses.default.child), childLeaving:(0,_clsx.default)(classes.childLeaving, _touchRippleClasses.default.childLeaving), 
      childPulsate:(0,_clsx.default)(classes.childPulsate, _touchRippleClasses.default.childPulsate)}, timeout:550, pulsate, rippleX, rippleY, rippleSize}, nextKey.current)]);
      nextKey.current += 1;
      rippleCallback.current = cb;
    }, [classes]), start = React.useCallback((event = {}, options = {}, cb = () => {
    }) => {
      const {pulsate = !1, center = centerProp || options.pulsate, fakeElement = !1} = options;
      if ("mousedown" === event?.type && ignoringMouseDown.current) {
        ignoringMouseDown.current = !1;
      } else {
        "touchstart" === event?.type && (ignoringMouseDown.current = !0);
        var rect = (options = fakeElement ? null : container.current) ? options.getBoundingClientRect() : {width:0, height:0, left:0, top:0};
        if (center || void 0 === event || 0 === event.clientX && 0 === event.clientY || !event.clientX && !event.touches) {
          var rippleX = Math.round(rect.width / 2);
          var rippleY = Math.round(rect.height / 2);
        } else {
          const {clientX, clientY} = event.touches && 0 < event.touches.length ? event.touches[0] : event;
          rippleX = Math.round(clientX - rect.left);
          rippleY = Math.round(clientY - rect.top);
        }
        if (center) {
          var rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);
          0 === rippleSize % 2 && (rippleSize += 1);
        } else {
          rippleSize = Math.sqrt((2 * Math.max(Math.abs((options ? options.clientWidth : 0) - rippleX), rippleX) + 2) ** 2 + (2 * Math.max(Math.abs((options ? options.clientHeight : 0) - rippleY), rippleY) + 2) ** 2);
        }
        event?.touches ? null === startTimerCommit.current && (startTimerCommit.current = () => {
          startCommit({pulsate, rippleX, rippleY, rippleSize, cb});
        }, startTimer.start(DELAY_RIPPLE, () => {
          startTimerCommit.current && (startTimerCommit.current(), startTimerCommit.current = null);
        })) : startCommit({pulsate, rippleX, rippleY, rippleSize, cb});
      }
    }, [centerProp, startCommit, startTimer]), pulsate = React.useCallback(() => {
      start({}, {pulsate:!0});
    }, [start]), stop = React.useCallback((event, cb) => {
      startTimer.clear();
      "touchend" === event?.type && startTimerCommit.current ? (startTimerCommit.current(), startTimerCommit.current = null, startTimer.start(0, () => {
        stop(event, cb);
      })) : (startTimerCommit.current = null, setRipples(oldRipples => 0 < oldRipples.length ? oldRipples.slice(1) : oldRipples), rippleCallback.current = cb);
    }, [startTimer]);
    React.useImperativeHandle(ref, () => ({pulsate, start, stop}), [pulsate, start, stop]);
    return (0,_jsxRuntime.jsx)(TouchRippleRoot, {className:(0,_clsx.default)(_touchRippleClasses.default.root, classes.root, className), ref:container, ...other, children:(0,_jsxRuntime.jsx)(_reactTransitionGroup.TransitionGroup, {component:null, exit:!0, children:ripples})});
  });
  require.propTypes = {center:global.default.bool, classes:global.default.object, className:global.default.string};
  exports.default = require;
};

//# sourceMappingURL=module$node_modules$$mui$material$node$ButtonBase$TouchRipple.js.map
