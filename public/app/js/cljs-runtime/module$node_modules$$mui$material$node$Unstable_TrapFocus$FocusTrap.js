shadow$provide.module$node_modules$$mui$material$node$Unstable_TrapFocus$FocusTrap = function(global, require, module, exports) {
  function defaultGetTabbable(root) {
    const regularTabNodes = [], orderedTabNodes = [];
    Array.from(root.querySelectorAll('input,select,textarea,a[href],button,[tabindex],audio[controls],video[controls],[contenteditable]:not([contenteditable\x3d"false"])')).forEach((node, i) => {
      var JSCompiler_inline_result = parseInt(node.getAttribute("tabindex") || "", 10);
      JSCompiler_inline_result = Number.isNaN(JSCompiler_inline_result) ? "true" === node.contentEditable || ("AUDIO" === node.nodeName || "VIDEO" === node.nodeName || "DETAILS" === node.nodeName) && null === node.getAttribute("tabindex") ? 0 : node.tabIndex : JSCompiler_inline_result;
      var JSCompiler_temp;
      (JSCompiler_temp = -1 === JSCompiler_inline_result) || ((JSCompiler_temp = node.disabled || "INPUT" === node.tagName && "hidden" === node.type) || ("INPUT" === node.tagName && "radio" === node.type && node.name ? ((JSCompiler_temp = node.ownerDocument.querySelector(`input[type="radio"]${`[name="${node.name}"]:checked`}`)) || (JSCompiler_temp = node.ownerDocument.querySelector(`input[type="radio"]${`[name="${node.name}"]`}`)), JSCompiler_temp = JSCompiler_temp !== node) : JSCompiler_temp = !1), 
      JSCompiler_temp = !!JSCompiler_temp);
      JSCompiler_temp || (0 === JSCompiler_inline_result ? regularTabNodes.push(node) : orderedTabNodes.push({documentOrder:i, tabIndex:JSCompiler_inline_result, node}));
    });
    return orderedTabNodes.sort((a, b) => a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex).map(a => a.node).concat(regularTabNodes);
  }
  function defaultIsEnabled() {
    return !0;
  }
  function FocusTrap(props) {
    const {children, disableAutoFocus = !1, disableEnforceFocus = !1, disableRestoreFocus = !1, getTabbable = defaultGetTabbable, isEnabled = defaultIsEnabled, open} = props, ignoreNextEnforceFocus = React.useRef(!1), sentinelStart = React.useRef(null), sentinelEnd = React.useRef(null), nodeToRestore = React.useRef(null), reactFocusEventTarget = React.useRef(null), activated = React.useRef(!1), rootRef = React.useRef(null);
    props = (0,_utils.unstable_useForkRef)((0,_utils.unstable_getReactElementRef)(children), rootRef);
    const lastKeydown = React.useRef(null);
    React.useEffect(() => {
      open && rootRef.current && (activated.current = !disableAutoFocus);
    }, [disableAutoFocus, open]);
    React.useEffect(() => {
      if (open && rootRef.current) {
        var doc = (0,_utils.unstable_ownerDocument)(rootRef.current);
        rootRef.current.contains(doc.activeElement) || (rootRef.current.hasAttribute("tabIndex") || (console.error('MUI: The modal content node does not accept focus.\nFor the benefit of assistive technologies, the tabIndex of the node is being set to "-1".'), rootRef.current.setAttribute("tabIndex", "-1")), activated.current && rootRef.current.focus());
        return () => {
          disableRestoreFocus || (nodeToRestore.current && nodeToRestore.current.focus && (ignoreNextEnforceFocus.current = !0, nodeToRestore.current.focus()), nodeToRestore.current = null);
        };
      }
    }, [open]);
    React.useEffect(() => {
      if (open && rootRef.current) {
        var doc = (0,_utils.unstable_ownerDocument)(rootRef.current), loopFocus = nativeEvent => {
          lastKeydown.current = nativeEvent;
          !disableEnforceFocus && isEnabled() && "Tab" === nativeEvent.key && doc.activeElement === rootRef.current && nativeEvent.shiftKey && (ignoreNextEnforceFocus.current = !0, sentinelEnd.current && sentinelEnd.current.focus());
        }, contain = () => {
          var rootElement = rootRef.current;
          if (null !== rootElement) {
            if (!doc.hasFocus() || !isEnabled() || ignoreNextEnforceFocus.current) {
              ignoreNextEnforceFocus.current = !1;
            } else {
              if (!(rootElement.contains(doc.activeElement) || disableEnforceFocus && doc.activeElement !== sentinelStart.current && doc.activeElement !== sentinelEnd.current)) {
                if (doc.activeElement !== reactFocusEventTarget.current) {
                  reactFocusEventTarget.current = null;
                } else if (null !== reactFocusEventTarget.current) {
                  return;
                }
                if (activated.current) {
                  var tabbable = [];
                  if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
                    tabbable = getTabbable(rootRef.current);
                  }
                  if (0 < tabbable.length) {
                    rootElement = !(!lastKeydown.current?.shiftKey || "Tab" !== lastKeydown.current?.key);
                    const focusNext = tabbable[0];
                    tabbable = tabbable[tabbable.length - 1];
                    "string" !== typeof focusNext && "string" !== typeof tabbable && (rootElement ? tabbable.focus() : focusNext.focus());
                  } else {
                    rootElement.focus();
                  }
                }
              }
            }
          }
        };
        doc.addEventListener("focusin", contain);
        doc.addEventListener("keydown", loopFocus, !0);
        var interval = setInterval(() => {
          doc.activeElement && "BODY" === doc.activeElement.tagName && contain();
        }, 50);
        return () => {
          clearInterval(interval);
          doc.removeEventListener("focusin", contain);
          doc.removeEventListener("keydown", loopFocus, !0);
        };
      }
    }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open, getTabbable]);
    const handleFocusSentinel = event => {
      null === nodeToRestore.current && (nodeToRestore.current = event.relatedTarget);
      activated.current = !0;
    };
    return (0,_jsxRuntime.jsxs)(React.Fragment, {children:[(0,_jsxRuntime.jsx)("div", {tabIndex:open ? 0 : -1, onFocus:handleFocusSentinel, ref:sentinelStart, "data-testid":"sentinelStart"}), React.cloneElement(children, {ref:props, onFocus:event => {
      null === nodeToRestore.current && (nodeToRestore.current = event.relatedTarget);
      activated.current = !0;
      reactFocusEventTarget.current = event.target;
      const childrenPropsHandler = children.props.onFocus;
      childrenPropsHandler && childrenPropsHandler(event);
    }}), (0,_jsxRuntime.jsx)("div", {tabIndex:open ? 0 : -1, onFocus:handleFocusSentinel, ref:sentinelEnd, "data-testid":"sentinelEnd"})]});
  }
  "use client";
  global = require("module$node_modules$$babel$runtime$helpers$interopRequireDefault").default;
  module = require("module$node_modules$$babel$runtime$helpers$interopRequireWildcard").default;
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.default = void 0;
  var React = module(require("module$node_modules$react$index"));
  global = global(require("module$node_modules$prop_types$index"));
  var _utils = require("module$node_modules$$mui$utils$index"), _jsxRuntime = require("module$node_modules$react$jsx_runtime");
  FocusTrap.propTypes = {children:_utils.elementAcceptingRef, disableAutoFocus:global.default.bool, disableEnforceFocus:global.default.bool, disableRestoreFocus:global.default.bool, getTabbable:global.default.func, isEnabled:global.default.func, open:global.default.bool.isRequired};
  FocusTrap.propTypes = (0,_utils.exactProp)(FocusTrap.propTypes);
  exports.default = FocusTrap;
};

//# sourceMappingURL=module$node_modules$$mui$material$node$Unstable_TrapFocus$FocusTrap.js.map
