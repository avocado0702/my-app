shadow$provide.module$node_modules$$mui$system$colorManipulator$colorManipulator = function(global, require, module, exports) {
  function clampWrapper(value, min = 0, max = 1) {
    (value < min || value > max) && console.error(`MUI: The value provided ${value} is out of range [${min}, ${max}].`);
    return (0,_clamp.default)(value, min, max);
  }
  function hexToRgb(color) {
    color = color.slice(1);
    (color = color.match(new RegExp(`.{1,${6 <= color.length ? 2 : 1}}`, "g"))) && 1 === color[0].length && (color = color.map(n => n + n));
    return color ? `rgb${4 === color.length ? "a" : ""}(${color.map((n, index) => 3 > index ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1000) / 1000).join(", ")})` : "";
  }
  function decomposeColor(color) {
    if (color.type) {
      return color;
    }
    if ("#" === color.charAt(0)) {
      return decomposeColor(hexToRgb(color));
    }
    const marker = color.indexOf("("), type = color.substring(0, marker);
    if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(type)) {
      throw Error(`MUI: Unsupported \`${color}\` color.\n` + "The following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().");
    }
    color = color.substring(marker + 1, color.length - 1);
    let colorSpace;
    if ("color" === type) {
      if (color = color.split(" "), colorSpace = color.shift(), 4 === color.length && "/" === color[3].charAt(0) && (color[3] = color[3].slice(1)), !["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(colorSpace)) {
        throw Error(`MUI: unsupported \`${colorSpace}\` color space.\n` + "The following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.");
      }
    } else {
      color = color.split(",");
    }
    color = color.map(value => parseFloat(value));
    return {type, values:color, colorSpace};
  }
  function recomposeColor(color) {
    const {type, colorSpace} = color;
    ({values:color} = color);
    type.includes("rgb") ? color = color.map((n, i) => 3 > i ? parseInt(n, 10) : n) : type.includes("hsl") && (color[1] = `${color[1]}%`, color[2] = `${color[2]}%`);
    color = type.includes("color") ? `${colorSpace} ${color.join(" ")}` : `${color.join(", ")}`;
    return `${type}(${color})`;
  }
  function hslToRgb(color) {
    color = decomposeColor(color);
    const {values} = color, h = values[0], l = values[2] / 100, a = values[1] / 100 * Math.min(l, 1 - l);
    var f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    let type = "rgb";
    f = [Math.round(255 * f(0)), Math.round(255 * f(8)), Math.round(255 * f(4))];
    "hsla" === color.type && (type += "a", f.push(values[3]));
    return recomposeColor({type, values:f});
  }
  function getLuminance(color) {
    color = decomposeColor(color);
    let rgb = "hsl" === color.type || "hsla" === color.type ? decomposeColor(hslToRgb(color)).values : color.values;
    rgb = rgb.map(val => {
      "color" !== color.type && (val /= 255);
      return 0.03928 >= val ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
    });
    return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
  }
  function alpha(color, value) {
    color = decomposeColor(color);
    value = clampWrapper(value);
    if ("rgb" === color.type || "hsl" === color.type) {
      color.type += "a";
    }
    color.values[3] = "color" === color.type ? `/${value}` : value;
    return recomposeColor(color);
  }
  function darken(color, coefficient) {
    color = decomposeColor(color);
    coefficient = clampWrapper(coefficient);
    if (color.type.includes("hsl")) {
      color.values[2] *= 1 - coefficient;
    } else if (color.type.includes("rgb") || color.type.includes("color")) {
      for (let i = 0; 3 > i; i += 1) {
        color.values[i] *= 1 - coefficient;
      }
    }
    return recomposeColor(color);
  }
  function lighten(color, coefficient) {
    color = decomposeColor(color);
    coefficient = clampWrapper(coefficient);
    if (color.type.includes("hsl")) {
      color.values[2] += (100 - color.values[2]) * coefficient;
    } else if (color.type.includes("rgb")) {
      for (var i = 0; 3 > i; i += 1) {
        color.values[i] += (255 - color.values[i]) * coefficient;
      }
    } else if (color.type.includes("color")) {
      for (i = 0; 3 > i; i += 1) {
        color.values[i] += (1 - color.values[i]) * coefficient;
      }
    }
    return recomposeColor(color);
  }
  function emphasize(color, coefficient = 0.15) {
    return 0.5 < getLuminance(color) ? darken(color, coefficient) : lighten(color, coefficient);
  }
  global = require("module$node_modules$$babel$runtime$helpers$interopRequireDefault").default;
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.alpha = alpha;
  exports.blend = function(background, overlay, opacity, gamma = 1.0) {
    var blendChannel = (b, o) => Math.round((b ** (1 / gamma) * (1 - opacity) + o ** (1 / gamma) * opacity) ** gamma);
    background = decomposeColor(background);
    overlay = decomposeColor(overlay);
    blendChannel = [blendChannel(background.values[0], overlay.values[0]), blendChannel(background.values[1], overlay.values[1]), blendChannel(background.values[2], overlay.values[2])];
    return recomposeColor({type:"rgb", values:blendChannel});
  };
  exports.colorChannel = void 0;
  exports.darken = darken;
  exports.decomposeColor = decomposeColor;
  exports.emphasize = emphasize;
  exports.getContrastRatio = function(foreground, background) {
    foreground = getLuminance(foreground);
    background = getLuminance(background);
    return (Math.max(foreground, background) + 0.05) / (Math.min(foreground, background) + 0.05);
  };
  exports.getLuminance = getLuminance;
  exports.hexToRgb = hexToRgb;
  exports.hslToRgb = hslToRgb;
  exports.lighten = lighten;
  exports.private_safeAlpha = function(color, value, warning) {
    try {
      return alpha(color, value);
    } catch (error) {
      return warning && console.warn(warning), color;
    }
  };
  exports.private_safeColorChannel = void 0;
  exports.private_safeDarken = function(color, coefficient, warning) {
    try {
      return darken(color, coefficient);
    } catch (error) {
      return warning && console.warn(warning), color;
    }
  };
  exports.private_safeEmphasize = function(color, coefficient, warning) {
    try {
      return emphasize(color, coefficient);
    } catch (error) {
      return warning && console.warn(warning), color;
    }
  };
  exports.private_safeLighten = function(color, coefficient, warning) {
    try {
      return lighten(color, coefficient);
    } catch (error) {
      return warning && console.warn(warning), color;
    }
  };
  exports.recomposeColor = recomposeColor;
  exports.rgbToHex = function(color) {
    if (color.startsWith("#")) {
      return color;
    }
    ({values:color} = decomposeColor(color));
    return `#${color.map((n, i) => {
      n = (3 === i ? Math.round(255 * n) : n).toString(16);
      return 1 === n.length ? `0${n}` : n;
    }).join("")}`;
  };
  global(require("module$node_modules$$mui$utils$formatMuiErrorMessage$index"));
  var _clamp = global(require("module$node_modules$$mui$utils$clamp$index"));
  const colorChannel = color => {
    const decomposedColor = decomposeColor(color);
    return decomposedColor.values.slice(0, 3).map((val, idx) => decomposedColor.type.includes("hsl") && 0 !== idx ? `${val}%` : val).join(" ");
  };
  exports.colorChannel = colorChannel;
  exports.private_safeColorChannel = (color, warning) => {
    try {
      return colorChannel(color);
    } catch (error) {
      return warning && console.warn(warning), color;
    }
  };
};

//# sourceMappingURL=module$node_modules$$mui$system$colorManipulator$colorManipulator.js.map
