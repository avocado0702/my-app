shadow$provide.module$node_modules$$mui$system$createStyled$createStyled = function(global, require, module, exports) {
  function shouldForwardProp(prop) {
    return "ownerState" !== prop && "theme" !== prop && "sx" !== prop && "as" !== prop;
  }
  function defaultOverridesResolver(slot) {
    return slot ? (_props, styles) => styles[slot] : null;
  }
  function processStyle(props, style) {
    style = "function" === typeof style ? style(props) : style;
    if (Array.isArray(style)) {
      return style.flatMap(subStyle => processStyle(props, subStyle));
    }
    if (Array.isArray(style?.variants)) {
      let rootStyle;
      if (style.isProcessed) {
        rootStyle = style.style;
      } else {
        const {variants, ...otherStyles} = style;
        rootStyle = otherStyles;
      }
      return processStyleVariants(props, style.variants, [rootStyle]);
    }
    return style?.isProcessed ? style.style : style;
  }
  function processStyleVariants(props, variants, results = []) {
    let mergedState;
    a: for (let i = 0; i < variants.length; i += 1) {
      const variant = variants[i];
      if ("function" === typeof variant.props) {
        if (mergedState ?? (mergedState = {...props, ...props.ownerState, ownerState:props.ownerState}), !variant.props(mergedState)) {
          continue;
        }
      } else {
        for (const key in variant.props) {
          if (props[key] !== variant.props[key] && props.ownerState?.[key] !== variant.props[key]) {
            continue a;
          }
        }
      }
      "function" === typeof variant.style ? (mergedState ?? (mergedState = {...props, ...props.ownerState, ownerState:props.ownerState}), results.push(variant.style(mergedState))) : results.push(variant.style);
    }
    return results;
  }
  function generateDisplayName(componentName, componentSlot, tag) {
    return componentName ? `${componentName}${(0,_capitalize.default)(componentSlot || "")}` : `Styled(${(0,_getDisplayName.default)(tag)})`;
  }
  function generateStyledLabel(componentName, componentSlot) {
    let label;
    componentName && (label = `${componentName}-${lowercaseFirstLetter(componentSlot || "Root")}`);
    return label;
  }
  function lowercaseFirstLetter(string) {
    return string ? string.charAt(0).toLowerCase() + string.slice(1) : string;
  }
  global = require("module$node_modules$$babel$runtime$helpers$interopRequireDefault").default;
  module = require("module$node_modules$$babel$runtime$helpers$interopRequireWildcard").default;
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.default = function(input = {}) {
    function styleAttachTheme(props) {
      a: {
        for (JSCompiler_inline_result in props.theme) {
          var JSCompiler_inline_result = !1;
          break a;
        }
        JSCompiler_inline_result = !0;
      }
      props.theme = JSCompiler_inline_result ? defaultTheme : props.theme[themeId] || props.theme;
    }
    const {themeId, defaultTheme = systemDefaultTheme, rootShouldForwardProp = shouldForwardProp, slotShouldForwardProp = shouldForwardProp} = input;
    return (tag, inputOptions = {}) => {
      (0,_styledEngine.internal_mutateStyles)(tag, styles => styles.filter(style => style !== _styleFunctionSx.default));
      const {name:componentName, slot:componentSlot, skipVariantsResolver:inputSkipVariantsResolver, skipSx:inputSkipSx, overridesResolver = defaultOverridesResolver(lowercaseFirstLetter(componentSlot)), ...options} = inputOptions, skipVariantsResolver = void 0 !== inputSkipVariantsResolver ? inputSkipVariantsResolver : componentSlot && "Root" !== componentSlot && "root" !== componentSlot || !1, skipSx = inputSkipSx || !1;
      inputOptions = shouldForwardProp;
      "Root" === componentSlot || "root" === componentSlot ? inputOptions = rootShouldForwardProp : componentSlot ? inputOptions = slotShouldForwardProp : "string" === typeof tag && 96 < tag.charCodeAt(0) && (inputOptions = void 0);
      const defaultStyledResolver = (0,_styledEngine.default)(tag, {shouldForwardProp:inputOptions, label:generateStyledLabel(componentName, componentSlot), ...options}), transformStyle = style => {
        if ("function" === typeof style && style.__emotion_real !== style) {
          return function(props) {
            return processStyle(props, style);
          };
        }
        if ((0,_deepmerge.isPlainObject)(style)) {
          const serialized = (0,_preprocessStyles.default)(style);
          return serialized.variants ? function(props) {
            return processStyle(props, serialized);
          } : serialized.style;
        }
        return style;
      };
      inputOptions = (...expressionsInput) => {
        var expressionsHead = [];
        expressionsInput = expressionsInput.map(transformStyle);
        const expressionsTail = [];
        expressionsHead.push(styleAttachTheme);
        componentName && overridesResolver && expressionsTail.push(function(props) {
          const styleOverrides = props.theme.components?.[componentName]?.styleOverrides;
          if (!styleOverrides) {
            return null;
          }
          const resolvedStyleOverrides = {};
          for (const slotKey in styleOverrides) {
            resolvedStyleOverrides[slotKey] = processStyle(props, styleOverrides[slotKey]);
          }
          return overridesResolver(props, resolvedStyleOverrides);
        });
        componentName && !skipVariantsResolver && expressionsTail.push(function(props) {
          const themeVariants = props.theme?.components?.[componentName]?.variants;
          return themeVariants ? processStyleVariants(props, themeVariants) : null;
        });
        skipSx || expressionsTail.push(_styleFunctionSx.default);
        if (Array.isArray(expressionsInput[0])) {
          const inputStrings = expressionsInput.shift(), placeholdersHead = Array(expressionsHead.length).fill(""), placeholdersTail = Array(expressionsTail.length).fill("");
          let outputStrings;
          outputStrings = [...placeholdersHead, ...inputStrings, ...placeholdersTail];
          outputStrings.raw = [...placeholdersHead, ...inputStrings.raw, ...placeholdersTail];
          expressionsHead.unshift(outputStrings);
        }
        expressionsHead = [...expressionsHead, ...expressionsInput, ...expressionsTail];
        expressionsHead = defaultStyledResolver(...expressionsHead);
        tag.muiName && (expressionsHead.muiName = tag.muiName);
        expressionsHead.displayName = generateDisplayName(componentName, componentSlot, tag);
        return expressionsHead;
      };
      defaultStyledResolver.withConfig && (inputOptions.withConfig = defaultStyledResolver.withConfig);
      return inputOptions;
    };
  };
  exports.shouldForwardProp = shouldForwardProp;
  exports.systemDefaultTheme = void 0;
  var _styledEngine = module(require("module$node_modules$$mui$styled_engine$node$index")), _deepmerge = require("module$node_modules$$mui$utils$deepmerge$index"), _capitalize = global(require("module$node_modules$$mui$utils$capitalize$index")), _getDisplayName = global(require("module$node_modules$$mui$utils$getDisplayName$index"));
  module = global(require("module$node_modules$$mui$system$createTheme$index"));
  var _styleFunctionSx = global(require("module$node_modules$$mui$system$styleFunctionSx$index")), _preprocessStyles = global(require("module$node_modules$$mui$system$preprocessStyles"));
  const systemDefaultTheme = exports.systemDefaultTheme = (0,module.default)();
};

//# sourceMappingURL=module$node_modules$$mui$system$createStyled$createStyled.js.map
