shadow$provide.module$node_modules$$mui$material$node$Popover$Popover = function(global, require, module, exports) {
  function getOffsetTop(rect, vertical) {
    let offset = 0;
    "number" === typeof vertical ? offset = vertical : "center" === vertical ? offset = rect.height / 2 : "bottom" === vertical && (offset = rect.height);
    return offset;
  }
  function getOffsetLeft(rect, horizontal) {
    let offset = 0;
    "number" === typeof horizontal ? offset = horizontal : "center" === horizontal ? offset = rect.width / 2 : "right" === horizontal && (offset = rect.width);
    return offset;
  }
  function getTransformOriginValue(transformOrigin) {
    return [transformOrigin.horizontal, transformOrigin.vertical].map(n => "number" === typeof n ? `${n}px` : n).join(" ");
  }
  function resolveAnchorEl(anchorEl) {
    return "function" === typeof anchorEl ? anchorEl() : anchorEl;
  }
  "use client";
  global = require("module$node_modules$$babel$runtime$helpers$interopRequireDefault").default;
  module = require("module$node_modules$$babel$runtime$helpers$interopRequireWildcard").default;
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.default = exports.PopoverRoot = exports.PopoverPaper = void 0;
  exports.getOffsetLeft = getOffsetLeft;
  exports.getOffsetTop = getOffsetTop;
  var React = module(require("module$node_modules$react$index"));
  module = global(require("module$node_modules$prop_types$index"));
  var _clsx = global(require("module$node_modules$clsx$dist$clsx")), _composeClasses = global(require("module$node_modules$$mui$utils$composeClasses$index")), _HTMLElementType = global(require("module$node_modules$$mui$utils$HTMLElementType$index")), _refType = global(require("module$node_modules$$mui$utils$refType$index")), _elementTypeAcceptingRef = global(require("module$node_modules$$mui$utils$elementTypeAcceptingRef$index")), _integerPropType = global(require("module$node_modules$$mui$utils$integerPropType$index")), 
  _chainPropTypes = global(require("module$node_modules$$mui$utils$chainPropTypes$index")), _isHostComponent = global(require("module$node_modules$$mui$material$node$utils$isHostComponent")), _zeroStyled = require("module$node_modules$$mui$material$node$zero_styled$index"), _DefaultPropsProvider = require("module$node_modules$$mui$material$node$DefaultPropsProvider$index"), _debounce = global(require("module$node_modules$$mui$material$node$utils$debounce")), _ownerDocument = global(require("module$node_modules$$mui$material$node$utils$ownerDocument")), 
  _ownerWindow = global(require("module$node_modules$$mui$material$node$utils$ownerWindow")), _useForkRef = global(require("module$node_modules$$mui$material$node$utils$useForkRef")), _Grow = global(require("module$node_modules$$mui$material$node$Grow$index")), _Modal = global(require("module$node_modules$$mui$material$node$Modal$index")), _Paper = global(require("module$node_modules$$mui$material$node$Paper$index")), _popoverClasses = require("module$node_modules$$mui$material$node$Popover$popoverClasses"), 
  _useSlot = global(require("module$node_modules$$mui$material$node$utils$useSlot")), _jsxRuntime = require("module$node_modules$react$jsx_runtime");
  const useUtilityClasses = ownerState => {
    ({classes:ownerState} = ownerState);
    return (0,_composeClasses.default)({root:["root"], paper:["paper"]}, _popoverClasses.getPopoverUtilityClass, ownerState);
  }, PopoverRoot = exports.PopoverRoot = (0,_zeroStyled.styled)(_Modal.default, {name:"MuiPopover", slot:"Root", overridesResolver:(props, styles) => styles.root})({}), PopoverPaper = exports.PopoverPaper = (0,_zeroStyled.styled)(_Paper.default, {name:"MuiPopover", slot:"Paper", overridesResolver:(props, styles) => styles.paper})({position:"absolute", overflowY:"auto", overflowX:"hidden", minWidth:16, minHeight:16, maxWidth:"calc(100% - 32px)", maxHeight:"calc(100% - 32px)", outline:0});
  require = React.forwardRef(function(inProps, ref) {
    var props = (0,_DefaultPropsProvider.useDefaultProps)({props:inProps, name:"MuiPopover"});
    const {action, anchorEl, anchorOrigin = {vertical:"top", horizontal:"left"}, anchorPosition, anchorReference = "anchorEl", children, className, container:containerProp, elevation = 8, marginThreshold = 16, open, PaperProps:PaperPropsProp = {}, slots = {}, slotProps = {}, transformOrigin = {vertical:"top", horizontal:"left"}, TransitionComponent = _Grow.default, transitionDuration:transitionDurationProp = "auto", TransitionProps:{onEntering, ...TransitionProps} = {}, disableScrollLock = !1, ...other} = 
    props;
    inProps = slotProps?.paper ?? PaperPropsProp;
    const paperRef = React.useRef(), ownerState = {...props, anchorOrigin, anchorReference, elevation, marginThreshold, externalPaperSlotProps:inProps, transformOrigin, TransitionComponent, transitionDuration:transitionDurationProp, TransitionProps}, classes = useUtilityClasses(ownerState), getAnchorOffset = React.useCallback(() => {
      if ("anchorPosition" === anchorReference) {
        return anchorPosition || console.error('MUI: You need to provide a `anchorPosition` prop when using \x3cPopover anchorReference\x3d"anchorPosition" /\x3e.'), anchorPosition;
      }
      var resolvedAnchorEl = resolveAnchorEl(anchorEl), anchorElement = resolvedAnchorEl && 1 === resolvedAnchorEl.nodeType ? resolvedAnchorEl : (0,_ownerDocument.default)(paperRef.current).body;
      resolvedAnchorEl = anchorElement.getBoundingClientRect();
      anchorElement = anchorElement.getBoundingClientRect();
      0 === anchorElement.top && 0 === anchorElement.left && 0 === anchorElement.right && 0 === anchorElement.bottom && console.warn("MUI: The `anchorEl` prop provided to the component is invalid.\nThe anchor element should be part of the document layout.\nMake sure the element is present in the document or that it's not display none.");
      return {top:resolvedAnchorEl.top + getOffsetTop(resolvedAnchorEl, anchorOrigin.vertical), left:resolvedAnchorEl.left + getOffsetLeft(resolvedAnchorEl, anchorOrigin.horizontal)};
    }, [anchorEl, anchorOrigin.horizontal, anchorOrigin.vertical, anchorPosition, anchorReference]), getTransformOrigin = React.useCallback(elemRect => ({vertical:getOffsetTop(elemRect, transformOrigin.vertical), horizontal:getOffsetLeft(elemRect, transformOrigin.horizontal)}), [transformOrigin.horizontal, transformOrigin.vertical]), getPositioningStyle = React.useCallback(element => {
      var elemRect = {width:element.offsetWidth, height:element.offsetHeight};
      element = getTransformOrigin(elemRect);
      if ("none" === anchorReference) {
        return {top:null, left:null, transformOrigin:getTransformOriginValue(element)};
      }
      var anchorOffset = getAnchorOffset();
      let top = anchorOffset.top - element.vertical;
      anchorOffset = anchorOffset.left - element.horizontal;
      var bottom = top + elemRect.height;
      const right = anchorOffset + elemRect.width;
      var containerWindow = (0,_ownerWindow.default)(resolveAnchorEl(anchorEl));
      const heightThreshold = containerWindow.innerHeight - marginThreshold;
      containerWindow = containerWindow.innerWidth - marginThreshold;
      null !== marginThreshold && top < marginThreshold ? (bottom = top - marginThreshold, top -= bottom, element.vertical += bottom) : null !== marginThreshold && bottom > heightThreshold && (bottom -= heightThreshold, top -= bottom, element.vertical += bottom);
      elemRect.height > heightThreshold && elemRect.height && heightThreshold && console.error(["MUI: The popover component is too tall.", `Some part of it can not be seen on the screen (${elemRect.height - heightThreshold}px).`, "Please consider adding a `max-height` to improve the user-experience."].join("\n"));
      null !== marginThreshold && anchorOffset < marginThreshold ? (elemRect = anchorOffset - marginThreshold, anchorOffset -= elemRect, element.horizontal += elemRect) : right > containerWindow && (elemRect = right - containerWindow, anchorOffset -= elemRect, element.horizontal += elemRect);
      return {top:`${Math.round(top)}px`, left:`${Math.round(anchorOffset)}px`, transformOrigin:getTransformOriginValue(element)};
    }, [anchorEl, anchorReference, getAnchorOffset, getTransformOrigin, marginThreshold]), [isPositioned, setIsPositioned] = React.useState(open), setPositioningStyles = React.useCallback(() => {
      const element = paperRef.current;
      if (element) {
        var positioning = getPositioningStyle(element);
        null !== positioning.top && element.style.setProperty("top", positioning.top);
        null !== positioning.left && (element.style.left = positioning.left);
        element.style.transformOrigin = positioning.transformOrigin;
        setIsPositioned(!0);
      }
    }, [getPositioningStyle]);
    React.useEffect(() => {
      disableScrollLock && window.addEventListener("scroll", setPositioningStyles);
      return () => window.removeEventListener("scroll", setPositioningStyles);
    }, [anchorEl, disableScrollLock, setPositioningStyles]);
    React.useEffect(() => {
      open && setPositioningStyles();
    });
    React.useImperativeHandle(action, () => open ? {updatePosition:() => {
      setPositioningStyles();
    }} : null, [open, setPositioningStyles]);
    React.useEffect(() => {
      if (open) {
        var handleResize = (0,_debounce.default)(() => {
          setPositioningStyles();
        }), containerWindow = (0,_ownerWindow.default)(anchorEl);
        containerWindow.addEventListener("resize", handleResize);
        return () => {
          handleResize.clear();
          containerWindow.removeEventListener("resize", handleResize);
        };
      }
    }, [anchorEl, open, setPositioningStyles]);
    props = transitionDurationProp;
    "auto" !== transitionDurationProp || TransitionComponent.muiSupportAuto || (props = void 0);
    const container = containerProp || (anchorEl ? (0,_ownerDocument.default)(resolveAnchorEl(anchorEl)).body : void 0), externalForwardedProps = {slots, slotProps:{...slotProps, paper:inProps}}, [PaperSlot, paperProps] = (0,_useSlot.default)("paper", {elementType:PopoverPaper, externalForwardedProps, additionalProps:{elevation, className:(0,_clsx.default)(classes.paper, inProps?.className), style:isPositioned ? inProps.style : {...inProps.style, opacity:0}}, ownerState}), [RootSlot, {slotProps:rootSlotPropsProp, 
    ...rootProps}] = (0,_useSlot.default)("root", {elementType:PopoverRoot, externalForwardedProps, additionalProps:{slotProps:{backdrop:{invisible:!0}}, container, open}, ownerState, className:(0,_clsx.default)(classes.root, className)});
    inProps = (0,_useForkRef.default)(paperRef, paperProps.ref);
    return (0,_jsxRuntime.jsx)(RootSlot, {...rootProps, ...(!(0,_isHostComponent.default)(RootSlot) && {slotProps:rootSlotPropsProp, disableScrollLock}), ...other, ref, children:(0,_jsxRuntime.jsx)(TransitionComponent, {appear:!0, in:open, onEntering:(element, isAppearing) => {
      onEntering && onEntering(element, isAppearing);
      setPositioningStyles();
    }, onExited:() => {
      setIsPositioned(!1);
    }, timeout:props, ...TransitionProps, children:(0,_jsxRuntime.jsx)(PaperSlot, {...paperProps, ref:inProps, children})})});
  });
  require.propTypes = {action:_refType.default, anchorEl:(0,_chainPropTypes.default)(module.default.oneOfType([_HTMLElementType.default, module.default.func]), props => {
    if (props.open && (!props.anchorReference || "anchorEl" === props.anchorReference)) {
      if ((props = resolveAnchorEl(props.anchorEl)) && 1 === props.nodeType) {
        if (props = props.getBoundingClientRect(), 0 === props.top && 0 === props.left && 0 === props.right && 0 === props.bottom) {
          return Error("MUI: The `anchorEl` prop provided to the component is invalid.\nThe anchor element should be part of the document layout.\nMake sure the element is present in the document or that it's not display none.");
        }
      } else {
        return Error(["MUI: The `anchorEl` prop provided to the component is invalid.", `It should be an Element or PopoverVirtualElement instance but it's \`${props}\` instead.`].join("\n"));
      }
    }
    return null;
  }), anchorOrigin:module.default.shape({horizontal:module.default.oneOfType([module.default.oneOf(["center", "left", "right"]), module.default.number]).isRequired, vertical:module.default.oneOfType([module.default.oneOf(["bottom", "center", "top"]), module.default.number]).isRequired}), anchorPosition:module.default.shape({left:module.default.number.isRequired, top:module.default.number.isRequired}), anchorReference:module.default.oneOf(["anchorEl", "anchorPosition", "none"]), BackdropComponent:module.default.elementType, 
  BackdropProps:module.default.object, children:module.default.node, classes:module.default.object, className:module.default.string, container:module.default.oneOfType([_HTMLElementType.default, module.default.func]), disableScrollLock:module.default.bool, elevation:_integerPropType.default, marginThreshold:module.default.number, onClose:module.default.func, open:module.default.bool.isRequired, PaperProps:module.default.shape({component:_elementTypeAcceptingRef.default}), slotProps:module.default.shape({paper:module.default.oneOfType([module.default.func, 
  module.default.object]), root:module.default.oneOfType([module.default.func, module.default.object])}), slots:module.default.shape({paper:module.default.elementType, root:module.default.elementType}), sx:module.default.oneOfType([module.default.arrayOf(module.default.oneOfType([module.default.func, module.default.object, module.default.bool])), module.default.func, module.default.object]), transformOrigin:module.default.shape({horizontal:module.default.oneOfType([module.default.oneOf(["center", 
  "left", "right"]), module.default.number]).isRequired, vertical:module.default.oneOfType([module.default.oneOf(["bottom", "center", "top"]), module.default.number]).isRequired}), TransitionComponent:module.default.elementType, transitionDuration:module.default.oneOfType([module.default.oneOf(["auto"]), module.default.number, module.default.shape({appear:module.default.number, enter:module.default.number, exit:module.default.number})]), TransitionProps:module.default.object};
  exports.default = require;
};

//# sourceMappingURL=module$node_modules$$mui$material$node$Popover$Popover.js.map
