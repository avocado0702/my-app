shadow$provide.module$node_modules$$emotion$react$dist$emotion_react_browser_cjs = function(global, require, module, exports) {
  function css() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return serialize.serializeStyles(args);
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  var emotionElement = require("module$node_modules$$emotion$react$dist$emotion_element_832b737b_browser_cjs");
  global = require("module$node_modules$react$index");
  var utils = require("module$node_modules$$emotion$utils$dist$emotion_utils_browser_cjs"), useInsertionEffectWithFallbacks = require("module$node_modules$$emotion$use_insertion_effect_with_fallbacks$dist$emotion_use_insertion_effect_with_fallbacks_browser_cjs"), serialize = require("module$node_modules$$emotion$serialize$dist$emotion_serialize_cjs");
  require("module$node_modules$$emotion$cache$dist$emotion_cache_browser_cjs");
  require("module$node_modules$$babel$runtime$helpers$extends");
  require("module$node_modules$$emotion$weak_memoize$dist$emotion_weak_memoize_cjs");
  require("module$node_modules$$emotion$react$_isolated_hnrs$dist$emotion_react__isolated_hnrs_browser_cjs");
  require("module$node_modules$hoist_non_react_statics$dist$hoist_non_react_statics_cjs");
  var React__namespace = function(e) {
    if (e && e.__esModule) {
      return e;
    }
    var n = Object.create(null);
    e && Object.keys(e).forEach(function(k) {
      if ("default" !== k) {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {enumerable:!0, get:function() {
          return e[k];
        }});
      }
    });
    n["default"] = e;
    return Object.freeze(n);
  }(global);
  require = function(type, props) {
    var args = arguments;
    if (null == props || !emotionElement.hasOwn.call(props, "css")) {
      return React__namespace.createElement.apply(void 0, args);
    }
    var argsLength = args.length, createElementArgArray = Array(argsLength);
    createElementArgArray[0] = emotionElement.Emotion;
    createElementArgArray[1] = emotionElement.createEmotionProps(type, props);
    for (var i = 2; i < argsLength; i++) {
      createElementArgArray[i] = args[i];
    }
    return React__namespace.createElement.apply(null, createElementArgArray);
  };
  global = emotionElement.withEmotionCache(function(props, cache) {
    var serialized = serialize.serializeStyles([props.styles], void 0, React__namespace.useContext(emotionElement.ThemeContext)), sheetRef = React__namespace.useRef();
    useInsertionEffectWithFallbacks.useInsertionEffectWithLayoutFallback(function() {
      var key = cache.key + "-global", sheet = new cache.sheet.constructor({key, nonce:cache.sheet.nonce, container:cache.sheet.container, speedy:cache.sheet.isSpeedy}), rehydrating = !1, node = document.querySelector('style[data-emotion\x3d"' + key + " " + serialized.name + '"]');
      cache.sheet.tags.length && (sheet.before = cache.sheet.tags[0]);
      null !== node && (rehydrating = !0, node.setAttribute("data-emotion", key), sheet.hydrate([node]));
      sheetRef.current = [sheet, rehydrating];
      return function() {
        sheet.flush();
      };
    }, [cache]);
    useInsertionEffectWithFallbacks.useInsertionEffectWithLayoutFallback(function() {
      var sheetRefCurrent = sheetRef.current, sheet = sheetRefCurrent[0];
      sheetRefCurrent[1] ? sheetRefCurrent[1] = !1 : (void 0 !== serialized.next && utils.insertStyles(cache, serialized.next, !0), sheet.tags.length && (sheet.before = sheet.tags[sheet.tags.length - 1].nextElementSibling, sheet.flush()), cache.insert("", serialized, sheet, !1));
    }, [cache, serialized.name]);
    return null;
  });
  var classnames = function classnames(args) {
    for (var len = args.length, i = 0, cls = ""; i < len; i++) {
      var arg = args[i];
      if (null != arg) {
        var toAdd = void 0;
        switch(typeof arg) {
          case "boolean":
            break;
          case "object":
            if (Array.isArray(arg)) {
              toAdd = classnames(arg);
            } else {
              toAdd = "";
              for (var k in arg) {
                arg[k] && k && (toAdd && (toAdd += " "), toAdd += k);
              }
            }
            break;
          default:
            toAdd = arg;
        }
        toAdd && (cls && (cls += " "), cls += toAdd);
      }
    }
    return cls;
  }, Insertion = function(_ref) {
    var cache = _ref.cache, serializedArr = _ref.serializedArr;
    useInsertionEffectWithFallbacks.useInsertionEffectAlwaysWithSyncFallback(function() {
      for (var i = 0; i < serializedArr.length; i++) {
        utils.insertStyles(cache, serializedArr[i], !1);
      }
    });
    return null;
  };
  module = emotionElement.withEmotionCache(function(props, cache) {
    var hasRendered = !1, serializedArr = [], css = function() {
      if (hasRendered && emotionElement.isDevelopment) {
        throw Error("css can only be used during render");
      }
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _len = serialize.serializeStyles(args, cache.registered);
      serializedArr.push(_len);
      utils.registerStyles(cache, _len, !1);
      return cache.key + "-" + _len.name;
    }, content = {css, cx:function() {
      if (hasRendered && emotionElement.isDevelopment) {
        throw Error("cx can only be used during render");
      }
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      _len2 = cache.registered;
      args = classnames(args);
      _key2 = [];
      _len2 = utils.getRegisteredStyles(_len2, _key2, args);
      args = 2 > _key2.length ? args : _len2 + css(_key2);
      return args;
    }, theme:React__namespace.useContext(emotionElement.ThemeContext)};
    props = props.children(content);
    hasRendered = !0;
    return React__namespace.createElement(React__namespace.Fragment, null, React__namespace.createElement(Insertion, {cache, serializedArr}), props);
  });
  exports.CacheProvider = emotionElement.CacheProvider;
  exports.ThemeContext = emotionElement.ThemeContext;
  exports.ThemeProvider = emotionElement.ThemeProvider;
  exports.__unsafe_useEmotionCache = emotionElement.__unsafe_useEmotionCache;
  exports.useTheme = emotionElement.useTheme;
  exports.withEmotionCache = emotionElement.withEmotionCache;
  exports.withTheme = emotionElement.withTheme;
  exports.ClassNames = module;
  exports.Global = global;
  exports.createElement = require;
  exports.css = css;
  exports.jsx = require;
  exports.keyframes = function() {
    var insertable = css.apply(void 0, arguments), name = "animation-" + insertable.name;
    return {name, styles:"@keyframes " + name + "{" + insertable.styles + "}", anim:1, toString:function() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }};
  };
};

//# sourceMappingURL=module$node_modules$$emotion$react$dist$emotion_react_browser_cjs.js.map
